<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>问题 | 新时空前端 / 博客</title>
    <meta name="generator" content="VuePress 1.8.2">
    <script src="https://www.googletagmanager.com/gtag/js?id=G-1PWBM2M60V" async="true"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-1PWBM2M60V');
      </script>
    <meta name="description" content="">
    
    <link rel="preload" href="/assets/css/0.styles.50167129.css" as="style"><link rel="preload" href="/assets/js/app.68aada41.js" as="script"><link rel="preload" href="/assets/js/6.f3d100af.js" as="script"><link rel="preload" href="/assets/js/9.313cbc20.js" as="script"><link rel="prefetch" href="/assets/js/2.36b38fb9.js"><link rel="prefetch" href="/assets/js/3.9ca748ea.js"><link rel="prefetch" href="/assets/js/4.fa5f21b6.js"><link rel="prefetch" href="/assets/js/5.a79be4a0.js"><link rel="prefetch" href="/assets/js/7.a82688ae.js"><link rel="prefetch" href="/assets/js/8.40480d1b.js">
    <link rel="stylesheet" href="/assets/css/0.styles.50167129.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container vuepress-theme-simple"><header class="header"><a href="/" title="" class="site-name router-link-active">
      新时空前端 / 博客
    </a> <div style="clear: both"></div> <!----></header> <section class="post-view"><div class="post-head"><h1 class="post-title">
      问题
    </h1> <time datetime="3/23/2021, 12:00:00 AM" title="3/23/2021, 12:00:00 AM" pubdate="pubdate" class="post-date">
  6 days ago
</time></div> <div class="content__default"><h2 id="js基础"><a href="#js基础" class="header-anchor">#</a> JS基础</h2> <blockquote><h3 id="判断数组"><a href="#判断数组" class="header-anchor">#</a> 判断数组</h3></blockquote> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">const</span> <span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// ES6</span>

<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment">// 最可靠</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token comment">// [object Array]</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token comment">// [object Object]</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>  <span class="token comment">// [object Function]</span>

<span class="token keyword">instanceof</span>
<span class="token comment">// instanceof用于检验构造函数的prototype属性是否出现在对象的原型链中</span>
arr <span class="token keyword">instanceof</span> <span class="token class-name">Array</span> <span class="token comment">// true</span>
<span class="token comment">/* 相当于 arr.__proto__ === Array.prototype
 * 存在的问题
 * prototype属性可以更改
 * 当有多个全局环境时，例如多个iframe窗口
 * Array.prototype !== iframe.Array.prototype
 */</span>
</code></pre></div><blockquote><h3 id="数组api"><a href="#数组api" class="header-anchor">#</a> 数组api</h3></blockquote> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// ES6 去重</span>
<span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span>
arr<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">// O(n^2)</span>
  <span class="token keyword">return</span> arr<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token operator">===</span> index
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// O(n) 不能区分字符串和数字</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  obj<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> i
<span class="token punctuation">}</span>
<span class="token punctuation">[</span><span class="token operator">...</span>Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">]</span>

Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>log

<span class="token comment">// ES5</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      arr<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
      j<span class="token operator">--</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 求和</span>
arr<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">total<span class="token punctuation">,</span> item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> total <span class="token operator">+</span> item
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
</code></pre></div><blockquote><h3 id="箭头函数"><a href="#箭头函数" class="header-anchor">#</a> 箭头函数</h3></blockquote> <div class="language-javascript extra-class"><pre class="language-javascript"><code>箭头函数和普通函数的区别
箭头函数的 <span class="token keyword">this</span> 是声明时确定还是运行时确定
箭头函数可以 <span class="token keyword">new</span> 吗 ？ 说一说 <span class="token keyword">new</span> 的原理
</code></pre></div><blockquote><h3 id="事件"><a href="#事件" class="header-anchor">#</a> 事件</h3></blockquote> <div class="language-text extra-class"><pre class="language-text"><code>JS事件的三个阶段：捕获阶段，目标阶段，冒泡阶段

捕获阶段：事件从Document节点自上而下向目标节点传播的阶段

目标阶段：目标节点处理事件的阶段

冒泡阶段：事件从目标节点向上传递的阶段

Ps: 以下事件没有冒泡
    onblur、onfocus、onmouseenter、onmouseleave

    addEventListener(event,function,useCapture)
    第三个参数用于设置事件传播类型，默认为false

    event.stopPropagation() 阻止事件传播

    event.preventDefault() 阻止事件默认行为
</code></pre></div><h2 id="浏览器相关"><a href="#浏览器相关" class="header-anchor">#</a> 浏览器相关</h2> <blockquote><h3 id="跨域"><a href="#跨域" class="header-anchor">#</a> 跨域</h3></blockquote> <div class="language-text extra-class"><pre class="language-text"><code>跨域产生的原因：
1. 不同主域名
2. 同一主域名不同子域名
3. 同一域名不同端口
4. 同一域名不同协议
5. 域名和域名对应ip

解决跨域的方法：
1. jsonp
动态添加script src属性，传入参数callback=functionName，后端返回functionName.call(undefined, data)

2. nginx反向代理
location /apis {
  proxy_pass: 后端接口地址
}
当请求以/apis开头时时会被nginx转发到接口地址

3. CORS 跨域共享资源

预检请求：
在发送非简单请求之前，浏览器会先发送一个OPTIONS方法，通过之后浏览器才会发送真正的请求

简单请求：
请求方法为GET、POST、HEAD，人为设置请求头为Accept、Accept-Language、Content-Language、
Content-Type（需要注意额外的限制）、DPR、Downlink、Save-Data、Viewport-Width、Width
Content-Type为text/plain、multipart/form-data、application/x-www-form-urlencoded为简单请求

预检请求request headers包括
Origin：表示请求来自哪个源
Access-Control-Request-Method：表示真实请求将使用的请求方法
Access-Control-Request-Headers：表示真实请求将使用的请求头部

服务器response headers包括
Access-Control-Allow-Origin：表示请求源可以访问
Access-Control-Allow-Methods：表示服务器允许访问的请求方法，可以设置多个，避免多次预检
Access-Control-Allow-Headers：表示服务器允许请求头中携带的字段
Access-Control-Max-Age：表示该响应的有效期，在有效期内无需再次发起预检

对于跨域请求，浏览器不会发送cookie，需要设置withCredentials: &quot;include&quot;
服务器设置响应头Access-Control-Allow-Credentials: true
</code></pre></div><blockquote><h3 id="路由"><a href="#路由" class="header-anchor">#</a> 路由</h3></blockquote> <div class="language-text extra-class"><pre class="language-text"><code>后端路由：
当用户访问url时，服务器会接收这个请求并解析url中的路径，当匹配成功时，分发到不同的controller处理

前端路由：
利用hash或者history API实现替换url并且不刷新页面

hash模式：
利用onhashchange监听URL的hash符后值的改变，可以用window.location.hash读取
hash模式下，仅hash符前的内容会被包含在请求中，因此对后端来说，即使没有配置路由也不会返回404

history模式：
利用pushState和replaceState替换url，并且不发起http请求，当刷新页面或者直接访问路径的时候会返回404
因此前端的URL必须和实际向后端发起请求的URL一致
</code></pre></div><blockquote><h3 id="懒加载"><a href="#懒加载" class="header-anchor">#</a> 懒加载</h3></blockquote> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Router</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    mode<span class="token operator">:</span> <span class="token string">'history'</span><span class="token punctuation">,</span>
    base<span class="token operator">:</span> process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">BASE_URL</span><span class="token punctuation">,</span>
    routes<span class="token operator">:</span> <span class="token punctuation">[</span>
        <span class="token punctuation">{</span>
            path<span class="token operator">:</span> <span class="token string">'/'</span><span class="token punctuation">,</span>
            name<span class="token operator">:</span> <span class="token string">'home'</span><span class="token punctuation">,</span>
            <span class="token function-variable function">component</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'/home'</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 原理解析 https://segmentfault.com/a/1190000022846552</span>
</code></pre></div><blockquote><h3 id="eventloop"><a href="#eventloop" class="header-anchor">#</a> EventLoop</h3></blockquote> <blockquote><h3 id="模块化"><a href="#模块化" class="header-anchor">#</a> 模块化</h3></blockquote> <blockquote><h3 id="服务端渲染"><a href="#服务端渲染" class="header-anchor">#</a> 服务端渲染</h3></blockquote> <blockquote><h3 id="url到请求返回"><a href="#url到请求返回" class="header-anchor">#</a> URL到请求返回</h3></blockquote> <div class="language-text extra-class"><pre class="language-text"><code>重绘
回流
</code></pre></div><blockquote><h3 id="cookie-sessionstorage-localstorage"><a href="#cookie-sessionstorage-localstorage" class="header-anchor">#</a> cookie sessionStorage localStorage</h3></blockquote> <div class="language-text extra-class"><pre class="language-text"><code>cookie是服务器发给客户端的特殊信息，以文本的方式保存在客户端，每次请求时都带上它
如果不在浏览器中设置过期时间，cookie被保存在内存中，生命周期随浏览器的关闭而结束
如果在浏览器中设置了cookie的过期时间，cookie被保存在硬盘中,直到过期时间结束才消失

cookie属性
1. Expires 过期时间
2. Max-Age 存活时间，单位为秒，过期则删除
3. domain 域名
4. path 路径
5. secure 只能通过https传输cookie
6. HttpOnly 只能通过http协议传输，不能通过JS访问
7. SameSite

缺点：1. 大小一般为4K
     2. 每次请求都需要带上cookie，浪费带宽
     3. 用户可以操作cookie
     
session是服务器创建用来存储各个用户信息的对象，每个用户有唯一的sessionID，并返回给浏览器用cookie保存

缺点：1. 依赖于cookie，用户可以操作cookie
     2. 服务器压力大
     
存储在sessionStorage中的数据会在页面关闭时清除，且相同URL不同Tabs的sessionStorage不共享
存储在localStorage中的数据会永久保存直到被清除
</code></pre></div><blockquote><h3 id="csrf攻击"><a href="#csrf攻击" class="header-anchor">#</a> CSRF攻击</h3></blockquote> <div class="language-textmate extra-class"><pre class="language-text"><code>CSRF(Cross-site request forgery),即跨站请求伪造,通常为攻击者诱导用户点击链接，利用用户已登录状态发起跨站请求

自动发起请求
&lt;img src=&quot;https://xxx.com/info?user=hhh&amp;count=100&quot; alt=&quot;&quot;/&gt;

进入页面后自动发送请求，这个请求会自动带上xxx.com的cookie信息
假如服务端没有验证机制，它可能认为发请求的是正常的用户，从而可以进行其他操作

防范措施
1. 利用Cookie的SameSite属性
SameSite可以设置为三个值，Strict、Lax和None
在Strict模式下，浏览器完全禁止第三方请求携带Cookie。比如请求xxx.com网站只能在xxx.com域名当中请求才能携带Cookie，在其他网站请求不能
在Lax模式下，只能在get方法提交表单或者a标签发送get请求的情况下可以携带Cookie，其他情况均不能
在None模式下，也就是默认模式，请求会自动携带上Cookie

2. 验证来源站点
请求头中有Origin和Referer字段，Origin只包含域名信息,Referer包含具体URL路径

3. CSRF Token
浏览器向服务器发送请求时，服务器生成一个字符串，将其植入到返回的页面中。
然后浏览器如果要发送请求，就必须带上这个字符串，然后服务器来验证是否合法，如果不合法则不予响应。

</code></pre></div><blockquote><h3 id="xss攻击"><a href="#xss攻击" class="header-anchor">#</a> XSS攻击</h3></blockquote> <div class="language-textmate extra-class"><pre class="language-text"><code>XSS(Cross Site Scripting),即跨站脚本，为了区分CSS故称为XSS。
XSS攻击是指浏览器中执行恶意脚本(无论是跨域还是同域)，从而拿到用户的信息并进行操作。

1. 存储型
由于对用户输入没有进行转义而保存在服务器，在页面渲染时直接执行。

2. 反射型
恶意脚本作为请求参数发送给服务端，然后由服务端返回给客户端，客户端将返回的内容作为HTML解析，直接执行

3. 文档型
文档型的XSS攻击并不会经过服务端，而是作为中间人的角色，在数据传输过程劫持到网络数据包，然后修改里面的html文档
</code></pre></div><blockquote><h3 id="前端缓存"><a href="#前端缓存" class="header-anchor">#</a> 前端缓存</h3></blockquote> <p>浏览器中的缓存作用分为两种情况，一种是需要发送HTTP请求，一种是不需要发送。</p> <ul><li>强缓存</li></ul> <div class="language-textmate extra-class"><pre class="language-text"><code>首先检查强缓存是否过期
通过服务端返回的响应头Cache-Control字段
该字段有max-age属性，单位是秒，即过期时间
其他属性：
public: 浏览器，中间代理服务器都进行缓存

private: 只有浏览器进行缓存，代理服务器不缓存

no-cache: 跳过当前强缓存，发送HTTP请求，即直接进入协商缓存阶段

no-store: 不进行任何缓存

s-maxage: 代理服务器缓存时间

must-revalidate: 缓存过期时，加上这个字段则必须从源服务器获取
</code></pre></div><p>当缓存过期，进入协商缓存</p> <ul><li>协商缓存</li></ul> <div class="language-textmate extra-class"><pre class="language-text"><code>强缓存失效后，浏览器在请求头中携带相应的缓存tag向服务器发送请求，服务器根据这个tag决定是否使用缓存

tag分为两种：Last-Modified/ETag

Last-Modified即最后修改时间，浏览器第一次给服务器发送请求和，服务器会在响应头中加上这个字段
浏览器接受以后，如果再次请求，会在请求头中携带If-Modified-Since，值为服务器传来的最后修改时间

服务器拿到请求头中的If-Modified-Since后，会与该资源的最后修改时间对比，如果请求头中的值小于这个值，说明更新了
否则返回304，告诉浏览器用缓存

ETag是服务器根据当前文件的内容，给文件生成的唯一标识，服务器通过响应头把这个值返回给浏览器
浏览器接收到ETag的值，会在下次请求中，将这个值作为If-None-Match这个字段的内容发送给服务器
服务器会与该资源的ETag进行对比...

两者对比

ETag比Last-Modified更精确的感知资源的变化
Last-Modified性能优于ETag，因为ETag需要生成哈希
当两种方式都支持的时候，浏览器优先考虑ETag
</code></pre></div><ul><li>缓存位置(优先级从高到低)</li></ul> <ol><li>Service Worker</li> <li>Memory Cache</li> <li>Disk Cache</li> <li>Push Cache</li></ol> <h3 id="http的基本结构"><a href="#http的基本结构" class="header-anchor">#</a> http的基本结构</h3> <div class="language-textmate extra-class"><pre class="language-text"><code>http由header+body组成，具体为 起始行 + 头部 + 空行 + 实体

起始行

对于请求报文，起始行由 方法 + 路径 + http版本组成
GET /home HTTP/1.1

对于响应报文，起始行由 http版本 + 状态码 + 原因组成
HTTP/1.1 200 OK

请求头/响应头格式：
1. 字段名不区分大小写
2. 字段名不允许出现空格，不可以出现下划线_
3. 字段名后面必须紧接着:

空行 用来区分头部和实体

实体 body
</code></pre></div><p>谈谈https的原理？为什么https能保证安全</p></div> <div></div></section> <footer class="footer">
  © 2021
  <i class="icon-user"></i> <a href="https://www.nst-fe.site/" target="_blank">
    nst-fe
  </a> <br>
  Powered by
  <a href="https://vuepress.vuejs.org/" rel="noopener" target="_blank">VuePress</a>
  | Theme
  <a href="https://github.com/viko16/vuepress-theme-simple" rel="noopener" target="_blank">Simple</a></footer></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.68aada41.js" defer></script><script src="/assets/js/6.f3d100af.js" defer></script><script src="/assets/js/9.313cbc20.js" defer></script>
  </body>
</html>
