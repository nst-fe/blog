---
title: 问题 
date: 2021-03-22
---

## JS基础

> ### 判断数组

 ```javascript
const arr = []
const obj = {}
const fn = () => {}

Array.isArray() // ES6

Object.prototype.toString.call()    // 最可靠
Object.prototype.toString.call(arr) // [object Array]
Object.prototype.toString.call(obj) // [object Object]
Object.prototype.toString.call(fn)  // [object Function]

instanceof
// instanceof用于检验构造函数的prototype属性是否出现在对象的原型链中
arr instanceof Array // true
 /* 相当于 arr.__proto__ === Array.prototype
  * 存在的问题
  * prototype属性可以更改
  * 当有多个全局环境时，例如多个iframe窗口
  * Array.prototype !== iframe.Array.prototype
  */
   ```

> ### 数组api

```javascript
// ES6 去重
const arr = [1, 1, 2, 2, 3, 3, 4, 4]
arr.filter((item, index) => {
  // O(n^2)
  return arr.indexOf(item) === index
})

// O(n) 不能区分字符串和数字
const obj = {}
for (let i = 0; i < arr.length; i++) {
  obj[arr[i]] = i
}
[...Object.keys(obj)]

Array.from(new Set(arr)).log

// ES5
for (var i = 0; i < arr.length; i++) {
  for (var j = i + 1; j < arr.length; j++) {
    if (arr[i] == arr[j]) {
      arr.splice(j, 1)
      j--
    }
  }
}

// 求和
arr.reduce((total, item) => {
  return total + item
}, 0)
 ```

> ### 事件

```text 
JS事件的三个阶段：捕获阶段，目标阶段，冒泡阶段

捕获阶段：事件从Document节点自上而下向目标节点传播的阶段

目标阶段：目标节点处理事件的阶段

冒泡阶段：事件从目标节点向上传递的阶段

Ps: 以下事件没有冒泡
    onblur、onfocus、onmouseenter、onmouseleave

    addEventListener(event,function,useCapture)
    第三个参数用于设置事件传播类型，默认为false

    event.stopPropagation() 阻止事件传播

    event.preventDefault() 阻止事件默认行为
```

## 浏览器相关

> ### 跨域

```text
跨域产生的原因：
1. 不同主域名
2. 同一主域名不同子域名
3. 同一域名不同端口
4. 同一域名不同协议
5. 域名和域名对应ip

解决跨域的方法：
1. jsonp
动态添加script src属性，传入参数callback=functionName，后端返回functionName.call(undefined, data)

2. nginx反向代理
location /apis {
  proxy_pass: 后端接口地址
}
当请求以/apis开头时时会被nginx转发到接口地址

3. CORS 跨域共享资源

预检请求：
在发送非简单请求之前，浏览器会先发送一个OPTIONS方法，通过之后浏览器才会发送真正的请求

简单请求：
请求方法为GET、POST、HEAD，人为设置请求头为Accept、Accept-Language、Content-Language、
Content-Type（需要注意额外的限制）、DPR、Downlink、Save-Data、Viewport-Width、Width
Content-Type为text/plain、multipart/form-data、application/x-www-form-urlencoded为简单请求

预检请求request headers包括
Origin：表示请求来自哪个源
Access-Control-Request-Method：表示真实请求将使用的请求方法
Access-Control-Request-Headers：表示真实请求将使用的请求头部

服务器response headers包括
Access-Control-Allow-Origin：表示请求源可以访问
Access-Control-Allow-Methods：表示服务器允许访问的请求方法，可以设置多个，避免多次预检
Access-Control-Allow-Headers：表示服务器允许请求头中携带的字段
Access-Control-Max-Age：表示该响应的有效期，在有效期内无需再次发起预检

对于跨域请求，浏览器不会发送cookie，需要设置withCredentials: "include"
服务器设置响应头Access-Control-Allow-Credentials: true
```

> ### cookie sessionStorage localStorage

```text
cookie是服务器发给客户端的特殊信息，以文本的方式保存在客户端，每次请求时都带上它
如果不在浏览器中设置过期时间，cookie被保存在内存中，生命周期随浏览器的关闭而结束
如果在浏览器中设置了cookie的过期时间，cookie被保存在硬盘中,直到过期时间结束才消失

缺点：1. 大小一般为4K
     2. 每次请求都需要带上cookie，浪费带宽
     3. 用户可以操作cookie
     
session是服务器创建用来存储各个用户信息的对象，每个用户有唯一的sessionID，并返回给浏览器用cookie保存

缺点：1. 依赖于cookie，用户可以操作cookie
     2. 服务器压力大
     
存储在sessionStorage中的数据会在页面关闭时清除，且相同URL不同Tabs的sessionStorage不共享
存储在localStorage中的数据会永久保存直到被清除
```
> ### 路由

```text
后端路由：
当用户访问url时，服务器会接收这个请求并解析url中的路径，当匹配成功时，分发到不同的controller处理

前端路由：
利用hash或者history API实现替换url并且不刷新页面

hash模式：
利用onhashchange监听URL的hash符后值的改变，可以用window.location.hash读取
hash模式下，仅hash符前的内容会被包含在请求中，因此对后端来说，即使没有配置路由也不会返回404

history模式：
利用pushState和replaceState替换url，并且不发起http请求，当刷新页面或者直接访问路径的时候会返回404
因此前端的URL必须和实际向后端发起请求的URL一致
``` 
> ### 懒加载
```javascript
const router = new Router({
    mode: 'history',
    base: process.env.BASE_URL,
    routes: [
        {
            path: '/',
            name: 'home',
            component: () => import('/home')
        },
    ]
})

// 原理解析 https://segmentfault.com/a/1190000022846552
```

> ### EventLoop

> ### 模块化

> ### 服务端渲染
