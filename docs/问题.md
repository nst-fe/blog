---
title: 问题 
date: 2021-03-23
---

## JS基础

> ### 判断数组

 ```javascript
const arr = []
const obj = {}
const fn = () => {}

Array.isArray() // ES6

Object.prototype.toString.call()    // 最可靠
Object.prototype.toString.call(arr) // [object Array]
Object.prototype.toString.call(obj) // [object Object]
Object.prototype.toString.call(fn)  // [object Function]

instanceof
// instanceof用于检验构造函数的prototype属性是否出现在对象的原型链中
arr instanceof Array // true
 /* 相当于 arr.__proto__ === Array.prototype
  * 存在的问题
  * prototype属性可以更改
  * 当有多个全局环境时，例如多个iframe窗口
  * Array.prototype !== iframe.Array.prototype
  */
   ```

> ### 数组api

```javascript
// ES6 去重
const arr = [1, 1, 2, 2, 3, 3, 4, 4]
arr.filter((item, index) => {
  // O(n^2)
  return arr.indexOf(item) === index
})

// O(n) 不能区分字符串和数字
const obj = {}
for (let i = 0; i < arr.length; i++) {
  obj[arr[i]] = i
}
[...Object.keys(obj)]

Array.from(new Set(arr)).log

// ES5
for (var i = 0; i < arr.length; i++) {
  for (var j = i + 1; j < arr.length; j++) {
    if (arr[i] == arr[j]) {
      arr.splice(j, 1)
      j--
    }
  }
}

// 求和
arr.reduce((total, item) => {
  return total + item
}, 0)
 ```

> ### 箭头函数

```javascript
箭头函数和普通函数的区别
箭头函数的 this 是声明时确定还是运行时确定
箭头函数可以 new 吗 ？ 说一说 new 的原理
```

> ### 事件

```text 
JS事件的三个阶段：捕获阶段，目标阶段，冒泡阶段

捕获阶段：事件从Document节点自上而下向目标节点传播的阶段

目标阶段：目标节点处理事件的阶段

冒泡阶段：事件从目标节点向上传递的阶段

Ps: 以下事件没有冒泡
    onblur、onfocus、onmouseenter、onmouseleave

    addEventListener(event,function,useCapture)
    第三个参数用于设置事件传播类型，默认为false

    event.stopPropagation() 阻止事件传播

    event.preventDefault() 阻止事件默认行为
```

## 浏览器相关

> ### 跨域

```text
跨域产生的原因：
1. 不同主域名
2. 同一主域名不同子域名
3. 同一域名不同端口
4. 同一域名不同协议
5. 域名和域名对应ip

解决跨域的方法：
1. jsonp
动态添加script src属性，传入参数callback=functionName，后端返回functionName.call(undefined, data)

2. nginx反向代理
location /apis {
  proxy_pass: 后端接口地址
}
当请求以/apis开头时时会被nginx转发到接口地址

3. CORS 跨域共享资源

预检请求：
在发送非简单请求之前，浏览器会先发送一个OPTIONS方法，通过之后浏览器才会发送真正的请求

简单请求：
请求方法为GET、POST、HEAD，人为设置请求头为Accept、Accept-Language、Content-Language、
Content-Type（需要注意额外的限制）、DPR、Downlink、Save-Data、Viewport-Width、Width
Content-Type为text/plain、multipart/form-data、application/x-www-form-urlencoded为简单请求

预检请求request headers包括
Origin：表示请求来自哪个源
Access-Control-Request-Method：表示真实请求将使用的请求方法
Access-Control-Request-Headers：表示真实请求将使用的请求头部

服务器response headers包括
Access-Control-Allow-Origin：表示请求源可以访问
Access-Control-Allow-Methods：表示服务器允许访问的请求方法，可以设置多个，避免多次预检
Access-Control-Allow-Headers：表示服务器允许请求头中携带的字段
Access-Control-Max-Age：表示该响应的有效期，在有效期内无需再次发起预检

对于跨域请求，浏览器不会发送cookie，需要设置withCredentials: "include"
服务器设置响应头Access-Control-Allow-Credentials: true
```

> ### 路由

```text
后端路由：
当用户访问url时，服务器会接收这个请求并解析url中的路径，当匹配成功时，分发到不同的controller处理

前端路由：
利用hash或者history API实现替换url并且不刷新页面

hash模式：
利用onhashchange监听URL的hash符后值的改变，可以用window.location.hash读取
hash模式下，仅hash符前的内容会被包含在请求中，因此对后端来说，即使没有配置路由也不会返回404

history模式：
利用pushState和replaceState替换url，并且不发起http请求，当刷新页面或者直接访问路径的时候会返回404
因此前端的URL必须和实际向后端发起请求的URL一致
``` 

> ### 懒加载

```javascript
const router = new Router({
    mode: 'history',
    base: process.env.BASE_URL,
    routes: [
        {
            path: '/',
            name: 'home',
            component: () => import('/home')
        }
    ]
})

// 原理解析 https://segmentfault.com/a/1190000022846552
```

> ### EventLoop

> ### 模块化

> ### 服务端渲染

> ### URL到请求返回

```text
重绘
回流
```

> ### cookie sessionStorage localStorage

```text
cookie是服务器发给客户端的特殊信息，以文本的方式保存在客户端，每次请求时都带上它
如果不在浏览器中设置过期时间，cookie被保存在内存中，生命周期随浏览器的关闭而结束
如果在浏览器中设置了cookie的过期时间，cookie被保存在硬盘中,直到过期时间结束才消失

cookie属性
1. Expires 过期时间
2. Max-Age 存活时间，单位为秒，过期则删除
3. domain 域名
4. path 路径
5. secure 只能通过https传输cookie
6. HttpOnly 只能通过http协议传输，不能通过JS访问
7. SameSite

缺点：1. 大小一般为4K
     2. 每次请求都需要带上cookie，浪费带宽
     3. 用户可以操作cookie
     
session是服务器创建用来存储各个用户信息的对象，每个用户有唯一的sessionID，并返回给浏览器用cookie保存

缺点：1. 依赖于cookie，用户可以操作cookie
     2. 服务器压力大
     
存储在sessionStorage中的数据会在页面关闭时清除，且相同URL不同Tabs的sessionStorage不共享
存储在localStorage中的数据会永久保存直到被清除
```


> ### CSRF攻击

```textmate
CSRF(Cross-site request forgery),即跨站请求伪造,通常为攻击者诱导用户点击链接，利用用户已登录状态发起跨站请求

自动发起请求
<img src="https://xxx.com/info?user=hhh&count=100" alt=""/>

进入页面后自动发送请求，这个请求会自动带上xxx.com的cookie信息
假如服务端没有验证机制，它可能认为发请求的是正常的用户，从而可以进行其他操作

防范措施
1. 利用Cookie的SameSite属性
SameSite可以设置为三个值，Strict、Lax和None
在Strict模式下，浏览器完全禁止第三方请求携带Cookie。比如请求xxx.com网站只能在xxx.com域名当中请求才能携带Cookie，在其他网站请求不能
在Lax模式下，只能在get方法提交表单或者a标签发送get请求的情况下可以携带Cookie，其他情况均不能
在None模式下，也就是默认模式，请求会自动携带上Cookie

2. 验证来源站点
请求头中有Origin和Referer字段，Origin只包含域名信息,Referer包含具体URL路径

3. CSRF Token
浏览器向服务器发送请求时，服务器生成一个字符串，将其植入到返回的页面中。
然后浏览器如果要发送请求，就必须带上这个字符串，然后服务器来验证是否合法，如果不合法则不予响应。

```

> ### XSS攻击

```textmate
XSS(Cross Site Scripting),即跨站脚本，为了区分CSS故称为XSS。
XSS攻击是指浏览器中执行恶意脚本(无论是跨域还是同域)，从而拿到用户的信息并进行操作。

1. 存储型
由于对用户输入没有进行转义而保存在服务器，在页面渲染时直接执行。

2. 反射型
恶意脚本作为请求参数发送给服务端，然后由服务端返回给客户端，客户端将返回的内容作为HTML解析，直接执行

3. 文档型
文档型的XSS攻击并不会经过服务端，而是作为中间人的角色，在数据传输过程劫持到网络数据包，然后修改里面的html文档
```

> ### 前端缓存

浏览器中的缓存作用分为两种情况，一种是需要发送HTTP请求，一种是不需要发送。

- 强缓存

```textmate
首先检查强缓存是否过期
通过服务端返回的响应头Cache-Control字段
该字段有max-age属性，单位是秒，即过期时间
其他属性：
public: 浏览器，中间代理服务器都进行缓存

private: 只有浏览器进行缓存，代理服务器不缓存

no-cache: 跳过当前强缓存，发送HTTP请求，即直接进入协商缓存阶段

no-store: 不进行任何缓存

s-maxage: 代理服务器缓存时间

must-revalidate: 缓存过期时，加上这个字段则必须从源服务器获取
```

当缓存过期，进入协商缓存

- 协商缓存

```textmate
强缓存失效后，浏览器在请求头中携带相应的缓存tag向服务器发送请求，服务器根据这个tag决定是否使用缓存

tag分为两种：Last-Modified/ETag

Last-Modified即最后修改时间，浏览器第一次给服务器发送请求和，服务器会在响应头中加上这个字段
浏览器接受以后，如果再次请求，会在请求头中携带If-Modified-Since，值为服务器传来的最后修改时间

服务器拿到请求头中的If-Modified-Since后，会与该资源的最后修改时间对比，如果请求头中的值小于这个值，说明更新了
否则返回304，告诉浏览器用缓存

ETag是服务器根据当前文件的内容，给文件生成的唯一标识，服务器通过响应头把这个值返回给浏览器
浏览器接收到ETag的值，会在下次请求中，将这个值作为If-None-Match这个字段的内容发送给服务器
服务器会与该资源的ETag进行对比...

两者对比

ETag比Last-Modified更精确的感知资源的变化
Last-Modified性能优于ETag，因为ETag需要生成哈希
当两种方式都支持的时候，浏览器优先考虑ETag
```

- 缓存位置(优先级从高到低)
1. Service Worker
2. Memory Cache
3. Disk Cache
4. Push Cache

### http的基本结构

```textmate
http由header+body组成，具体为 起始行 + 头部 + 空行 + 实体

起始行

对于请求报文，起始行由 方法 + 路径 + http版本组成
GET /home HTTP/1.1

对于响应报文，起始行由 http版本 + 状态码 + 原因组成
HTTP/1.1 200 OK

请求头/响应头格式：
1. 字段名不区分大小写
2. 字段名不允许出现空格，不可以出现下划线_
3. 字段名后面必须紧接着:

空行 用来区分头部和实体

实体 body
```
谈谈https的原理？为什么https能保证安全
